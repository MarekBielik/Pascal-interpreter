/* POPIS OBRAZKA */
/* pokusal som sa to nejak napisat,
** tazko sa o tom pise :D
*/

/* vzorovy program - priblizne */
var
	a:integer;

function func(n:integer):integer;
	
	var
		a:integer;

begin
	func := n+a;
end;

begin
	
	a:=6;
	a:=func(a);

end.

/*  */

** Parser zacne svoju analyzu, rozbaluje nejake prve
pravidla, narazí na ::var:: rozbali pravidlo pre premenne
tokeny chodia, pride identifikátor ::a:: > pozrieme do GLOB TABulky
kedze vieme ze sa jedna o pravidlo var mimo funkcie,
::a:: sme nenašli tak ho tam vložíme + vieme že je to VAR_ID,
niekde si držíme ukazatel na toto práve vložené ::a:: napr ACTIVE,
dalej nacítame dvojbodku a zatým >>TYP<< ::integer::,
vlozíme do TAB do ACTIVE prvku teda ::a:: o aky typ sa jedná
príde nám ::stredník:: tým sa končí toto 1 pravidlo z parseru
@ teraz máme všetko potrebné pre VYGENEROVANIE INSTRUKCIE
@@ INSTRUKCIA pre alokaciu tejto premennej

/* toto miesto bude naalokovane az ked bude prebiehať
** interpret, cize az niekedy neskor az ked budu 
** vsetky instrukcie v instrukcnej paske a zacne 
** vykonavanie >> to znamena ze presnu ADRESU
** naalokovaneho miesta budeme mať až neskor
** ale instrukciu treba generovat teraz
** @ riesenie
** v GLOB TAB máme uložený identifikátor ::a::
** má tam položku DAT, v ACTIVE máme ukazatel(adresu)
** do TAB na ::a:: >> cize mozme povedat ze do DAT
** si niekedy neskor dame adresu ALOKACIE
** >> to znamena že teraz
** @@ VYTVORIME INSTRUKCIU ALOKACIE
** taku,ze ADRESU jej nastavíme na práve teraz ACTIV-ny
** ::a::DAT  $$$ OBR X1 $$$
** // podla TYPU vieme kolko pamete alokovat
** :vysvetlenie > v instrukcii je ADRESA na ktorej 
** bude ulozena ADRESA na alokovane miesto
** vid $$$ šípka S1 $$$
*/

// pokracovanie
VAR list hotovo .. uz nam zacina function list
pri spustani programu budu funkcie preskocene 
a bude sa zacinat hlavnym programom od begin
@@ vygeneruje sa INSTRUKCIA SKOKU 
zatial nevieme kam

pride token function...rozvinie sa pravidlo...
pride ::func:: vieme podla pravidla ze sme 
vo function liste.. pozrieme do GLOB TAB
::func:: sa nenachadza.. ok .. ulozime do tabulky
vieme ze je to funkcia cize pridame aj F_ID
nastavime si ze prave pracujeme s tymto prvkom z TAB
cize ACTIVE.. dalej nám príde ::n:: vieme ze sa jedna
o parameter dalej dvojbodka dalej vieme ze to je
VAR_ID , integer,.. ** tu este neviem ako sa budu alokovat
parametre funkcii... treba doriesit...
dalej nám pride ) a zatým :ineger vieme uz navratovu hodnotu
funkcie poznacime si do GLOB TAB do ACTIVE prvku
strednik.ok
dalej nám príde ::var:: .. nieco podobne ako pri global
ale teraz máme vytvorenú tabulku LOKAL pre "func"
príde nám ::a:: je to identifikator ... pozrieme sa do
LOKAL tabuky ci take nieco uz mame, nie tak ulozime
drzime si LOKAL.ACTIVE ukladame ze je to VAR_ID, integer
@@ mozme generovat instrukciu alokacie
ale pozor na adresu 
musíme sa zamysliet ze tam bude viac FRAME
FRAME budu vyriesene ZASOBNIKOM
cize ADRESA kde bude ulozena adresa alokacie bude
STACK->TOP-> (sem dosadit vyhladanie v tabulke podla
identifikatoru teraz "a") ->DAT $$$ obr X2 $$$

ukoncime varlist
zacina begin funkcie rozvijame pravidla...
mame tu nejake priradenie...do func... takze sa pozrieme co to je v TAB..
vidime ze je to F_ID cize vieme
ze sa bude jednat onavratovu hodnotu funkcie
je tam znak priradenie v tomto momente sa pusta
PRECEDENCNA ... ktora tiez priamo bude generovat
určité inštruckie... $$$ obr X3 $$$
ked skončí OK, vieme že nám niečo zanehala tak 
@@ GENERUJEME inštrukciu pre priradenie
adresa KDE sa bude ukladat je STACK->TOP-> najdi "func"
-> DAT   , ostatne zostane prazdne / NULL
pretoze precendecna nehala po sebe na pomocnom zasobniku(ten riesi interpreter)
nejaku hodnotu a ta sa vytiahne z toho zasobniku

mame end;
@@ generujeme instrukciu JMP SKOKU na adresu 
nejakeho zasobniku/nejakej premennej kde sme si ulozili
adresu na instrukcnej paske odkial sme zacali vykonavat
instrukciu 
!!!!!! :: treba si to predstavit lebo tu adresu
ziskame az neskor v inej instrukcii...

>>> teraz zacina hlavny program BEGIN
cize @@ generujeme instrukciu, ktora nam ulozi 
do premennenj "ZACIATOK PROGRAMU" adresu aktualne instrukcie

to je potrebne pre instrukciu co sme spominali uz hore
ze sa budu preskakovat FUNKCIE lebo program zacina TU!

pride nam a:=6; ::a:: si pametame spustime
precendecnu ta vytvori instrkcie podla poradia spracovania
vrati sa nam .. @@ generuje instrukciu priradenie tak
ako aj predtym,..
strednik ok
dalsie priradenie.. no tentokrat so spustenim FCIE

tu sa @@ generuje instruckia ktora ulozi do nejakej
premennej / nejakeho zasobniku adresu KAM sa ma vratit
po skonceni funkcie (zase vidno ze ta instrukcia uz 
bola volakde hore ale az tu sa dozvie tie adresy)
@@ generujeme instrukcie pre vytvorenie noveho ramca
cize vytvorime TABULKU LOKAL pre "func" a jej adresu
dame na zasobnik > tym sme vytvorili frame
> a zase sa mozme zamysliet ako to vobec funguje
ze hore niekde som pisal STACK->TOP aj ked som tie 
adresy este nemal..

potom sa GENERUJE instrukcia skoku na zaciatok 
funkcie.. cize u nas niekde na zaciatok pasky...
 ked instrukcia konci skoci sa sem zase naspet 
 > pretoze ked sme vytvarali tu funkciu tak sme generovali
 instrukciu ktora skoci na adresu ktoru si vytiahne niekde zo zasobnika...


 /* nie je to 100 percentne ale pre predstavu/pochopenie
 ** to dufam bude stacit :D
 */
